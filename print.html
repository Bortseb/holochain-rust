<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>holochain_101</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li><ol class="section"><li><a href="overview.html"><strong aria-hidden="true">1.1.</strong> Overview</a></li></ol></li><li><a href="planning_a_dapp.html"><strong aria-hidden="true">2.</strong> Planning a dApp</a></li><li><a href="building_apps.html"><strong aria-hidden="true">3.</strong> Building Holochain Apps</a></li><li><ol class="section"><li><a href="zome/api_globals.html"><strong aria-hidden="true">3.1.</strong> using zome API global variables</a></li><li><a href="zome/api_functions.html"><strong aria-hidden="true">3.2.</strong> using zome API functions</a></li><li><ol class="section"><li><a href="zome/implementation.html"><strong aria-hidden="true">3.2.1.</strong> implementing zome API functions</a></li></ol></li><li><a href="zome/callback_functions.html"><strong aria-hidden="true">3.3.</strong> using callback functions</a></li><li><a href="agent.html"><strong aria-hidden="true">3.4.</strong> Agent</a></li><li><a href="keys.html"><strong aria-hidden="true">3.5.</strong> Keys</a></li><li><a href="dna.html"><strong aria-hidden="true">3.6.</strong> DNA</a></li><li><a href="source_chain.html"><strong aria-hidden="true">3.7.</strong> Source Chain</a></li><li><ol class="section"><li><a href="pairs.html"><strong aria-hidden="true">3.7.1.</strong> Pairs</a></li></ol></li><li><a href="distributed_hash_table.html"><strong aria-hidden="true">3.8.</strong> Distributed Hash Table</a></li><li><a href="lifecycle_of_an_entry.html"><strong aria-hidden="true">3.9.</strong> Lifecycle of an Entry</a></li><li><a href="links.html"><strong aria-hidden="true">3.10.</strong> Links Entries</a></li><li><a href="core_api.html"><strong aria-hidden="true">3.11.</strong> Core API</a></li><li><a href="wasm.html"><strong aria-hidden="true">3.12.</strong> WASM</a></li><li><a href="command_line_tools.html"><strong aria-hidden="true">3.13.</strong> Command Line Tools</a></li><li><a href="holochain_across_platforms.html"><strong aria-hidden="true">3.14.</strong> Holochain Across Platforms</a></li></ol></li><li><a href="live_hc_apps.html"><strong aria-hidden="true">4.</strong> Going Live with Holochain Apps</a></li><li><a href="extending_hc_platform.html"><strong aria-hidden="true">5.</strong> Extending the Holochain Platform</a></li><li><ol class="section"><li><a href="state_actions.html"><strong aria-hidden="true">5.1.</strong> Redux Architecture</a></li><li><ol class="section"><li><a href="state/actions.html"><strong aria-hidden="true">5.1.1.</strong> State actions</a></li></ol></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">holochain_101</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#welcome" id="welcome"><h1>Welcome</h1></a>
<p>Welcome, you've discovered the book on Holochain. It will guide you comprehensively through everything you need to know about the creation of fully peer-to-peer, secure, and decentralized applications built with Holochain. It also includes a section on contributing to, and extending, Holochain itself.</p>
<p>Holochain is an open source software library that provides a comprehensive solution for businesses, communities, and any group of people to build and run applications which are hosted and validated by the &quot;users&quot; themselves, providing a superior level of agency and autonomy over heavy reliance on the so-called &quot;cloud&quot; and third parties. &quot;Users&quot; cease to merely &quot;use&quot; an application. By running it, they participate equally as nodes in the network, hosting and validating data, in addition to consuming it. Holochain provides a cross-platform framework for the development and execution of these applications. Applications can be developed utilizing any of the major operating systems in use, and run on any device with a 64-bit architecture. From desktops to laptops to Android (arm64) devices, a whole new set of opportunites open for the p2p applications you've been dreaming and scheming about.</p>
<p>This book will explain in depth how Holochain performs its myriad functions, from data validation to data propogation, so that you can get on with what you really want to do,develop an important new application to serve your business, community, or otherwise.</p>
<a class="header" href="print.html#overview" id="overview"><h1>Overview</h1></a>
<p>Depending on whether your interest is specific, or general, you may wish to read it front to back, or skip to specific sections of the book. If the summary of a section describes you, then it's a section for you!</p>
<a class="header" href="print.html#planning-a-dapp" id="planning-a-dapp"><h3>Planning a dApp</h3></a>
<p><strong>Readers:</strong> You can't put the horse before the cart. First things first:  understanding the landscape of decentralized apps. What are the mechanics of a functioning decentralized app? You have an idea of what you want to build, and you need to get a grasp on what it's going to take. You need to know what your blind spots are, and what are the common pitfalls. You need to know which of your assumptions to hold on to, and which to let go.</p>
<p><strong>Writing:</strong> General Audience</p>
<a class="header" href="print.html#building-holochain-apps" id="building-holochain-apps"><h3>Building Holochain Apps</h3></a>
<p><strong>Readers:</strong> Whether you're a seasoned developer, or just starting out, you're in it to write code. You've either got an app project (or five) on the go, or you're in it to experiment and test the limits. You need to know what you need to know. You want to talk Holochain's language. You're an intrepid explorer of technical documentation.</p>
<p><strong>Writing:</strong> Technical, Explanatory &amp; How-to</p>
<a class="header" href="print.html#going-live-with-holochain-apps" id="going-live-with-holochain-apps"><h3>Going Live with Holochain Apps</h3></a>
<p><strong>Readers:</strong> You're involved in the conception, development, or design of a Holochain app, and you've got to know how to get your app out into the world, into the hands of the people who need it. You've got questions like &quot;How do updates to the app work?&quot;, &quot;How do I track performance of the app?&quot;, &quot;What are best practices for security?&quot;</p>
<p><strong>Writing:</strong> General Audience</p>
<a class="header" href="print.html#extending-the-holochain-platform" id="extending-the-holochain-platform"><h3>Extending the Holochain Platform</h3></a>
<p><strong>Readers:</strong> You want to look at Holochain itself, not what you can build with it, but to see what you can tweak, or contribute. You've got ideas for Holochain and got skills to pull them off. You're reading the Holochain source code, or source documentation. Maybe you want to enable app development in a whole other language not available yet, or maybe to run Holochain on a device or platform not supported yet. You can make sense of terse technical language, and direct yourself well.</p>
<p><strong>Writing:</strong> Technical, Explanatory &amp; How-to</p>
<a class="header" href="print.html#planning-a-dapp-1" id="planning-a-dapp-1"><h1>Planning a dApp</h1></a>
<a class="header" href="print.html#building-apps" id="building-apps"><h1>Building Apps</h1></a>
<a class="header" href="print.html#zome-api-constants-and-application-variables" id="zome-api-constants-and-application-variables"><h1>Zome API Constants and Application Variables</h1></a>
<p>There are two kinds of API values that are available in zome code:</p>
<ol>
<li>system-wide global constants</li>
<li>app-specific global variables</li>
</ol>
<a class="header" href="print.html#reference" id="reference"><h2>Reference</h2></a>
<p>Note: Full reference is available in language-specific API Reference documentation.
(TODO add links)</p>
<a class="header" href="print.html#system-wide-global-constants" id="system-wide-global-constants"><h3>System-wide global constants</h3></a>
<table><thead><tr><th> Name        </th><th align="left"> Purpose           </th></tr></thead><tbody>
<tr><td> VERSION      </td><td align="left"> Version of the Holochain software running the zome </td></tr>
<tr><td> HashNotFound      </td><td align="left"> Value returned when a hash provided could not be found. </td></tr>
<tr><td> Status </td><td align="left"> Enum holding all possible state of an entry. </td></tr>
<tr><td> GetEntryMask </td><td align="left"> Mask values used for calling the <code>get_entry</code> Zome API Function. </td></tr>
<tr><td> LinkAction </td><td align="left"> Constants used for calling the <code>link_entries</code> Zome API Function. </td></tr>
<tr><td> PkgRequest </td><td align="left"> TODO </td></tr>
<tr><td> ChainOption </td><td align="left"> TODO </td></tr>
<tr><td> BridgeSide </td><td align="left"> TODO </td></tr>
<tr><td> SysEntryType </td><td align="left"> Enum holding all possible types of system entries </td></tr>
<tr><td> bundle_cancel.Reason </td><td align="left"> Enum used as argument for <code>bundle_canceled</code> callback </td></tr>
<tr><td> bundle_cancel.Response </td><td align="left"> Enum used as return value for <code>bundle_canceled</code> callback </td></tr>
</tbody></table>
<a class="header" href="print.html#app-specific-global-variables" id="app-specific-global-variables"><h3>app-specific global variables</h3></a>
<table><thead><tr><th> Name        </th><th> Purpose           </th></tr></thead><tbody>
<tr><td> APP_NAME </td><td align="left"> Name of the Holochain app taken from the DNA. </td></tr>
<tr><td> APP_DNA_HASH </td><td align="left"> The hash of this Holochain's DNA </td></tr>
<tr><td> APP_AGENT_ID_STR </td><td align="left"> The identity string used to initialize this Holochain with <code>hcadmin init</code>. </td></tr>
<tr><td> APP_AGENT_KEY_HASH </td><td align="left"> The hash of local agent's public key. </td></tr>
<tr><td> APP_AGENT_INITIAL_HASH </td><td align="left"> The hash of the first identity entry on the local chain. </td></tr>
<tr><td> APP_AGENT_LATEST_HASH </td><td align="left"> The hash of the most recent identity entry that has been committed to the local chain. </td></tr>
</tbody></table>
<a class="header" href="print.html#zome-api-functions" id="zome-api-functions"><h1>Zome API functions</h1></a>
<a class="header" href="print.html#overview-1" id="overview-1"><h2>Overview</h2></a>
<p>A Zome API Function is any Holochain core functionality that is exposed as a
callable function within zome code.</p>
<p>Compare this to a Zome Callback Function, which is implemented by the zome code
and called by Holochain.</p>
<p>So, zome functions (functions in the zome code) are called by Holochain,
which can optionally call Zome API Functions, and then finally return a
value back to Holochain.</p>
<pre><code>Holochain blocks
  -&gt; calls zome function
  -&gt; executes WASM logic compiled from zome language
  -&gt; zome logic calls zome API function
    -&gt; Holochain natively executes zome API function
    -&gt; Holochain returns value to zome function
  -&gt; zome function returns some value
  -&gt; Holochain receives final value of zome function
</code></pre>
<p>Each Zome API Function has a canonical name used internally by Holochain.</p>
<p>Zome code can be written in any language that compiles to WASM. This means the
canonical function name and the function name in the zome language might be
different. The zome language will closely mirror the canonical names, but naming
conventions such as capitalisation of the zome language are also respected.</p>
<p>For example, the canonical <code>verify_signature</code> might become <code>verifySignature</code> in
JavaScript.</p>
<p>When a zome API function is called from within zome code a corresponding Rust
function is called. The Rust function is passed the current zome runtime and the
arguments that the zome API function was called with. The Rust function connects
zome logic to Holochain core functionality and often has side effects. The
return value of the Rust function is passed back to the zome code as the return
of the zome API function.</p>
<a class="header" href="print.html#reference-1" id="reference-1"><h2>Reference</h2></a>
<p>Note: Full reference is available in language-specific API Reference documentation.
(TODO add links)</p>
<a class="header" href="print.html#property" id="property"><h3>Property</h3></a>
<p>Canonical name: <code>property</code></p>
<p>Returns an application property, which are defined by the app developer in the DNA.
It returns values from the DNA file that you set as properties of your application (e.g. Name, Language, Description, Author, etc.).</p>
<a class="header" href="print.html#make-hash" id="make-hash"><h3>Make Hash</h3></a>
<p>Canonical name: <code>make_hash</code></p>
<p>TODO</p>
<a class="header" href="print.html#debug" id="debug"><h3>Debug</h3></a>
<p>Canonical name: <code>debug</code></p>
<p>Debug sends the passed arguments to the log that was given to the Holochain instance and returns <code>None</code>.</p>
<a class="header" href="print.html#call" id="call"><h3>Call</h3></a>
<p>Canonical name: <code>call</code></p>
<p>TODO</p>
<a class="header" href="print.html#sign" id="sign"><h3>Sign</h3></a>
<p>Canonical name: <code>sign</code></p>
<p>TODO</p>
<a class="header" href="print.html#verify-signature" id="verify-signature"><h3>Verify Signature</h3></a>
<p>Canonical name: <code>verify_signature</code></p>
<p>TODO</p>
<a class="header" href="print.html#commit-entry" id="commit-entry"><h3>Commit Entry</h3></a>
<p>Canonical name: <code>commit_entry</code></p>
<p>Given an entry type and content, commits an entry to the local source chain.
On success, returns the hash of the entry.</p>
<a class="header" href="print.html#update-entry" id="update-entry"><h3>Update Entry</h3></a>
<p>Canonical name: <code>update_entry</code></p>
<p>TODO</p>
<a class="header" href="print.html#update-agent" id="update-agent"><h3>Update Agent</h3></a>
<p>Canonical name: <code>update_agent</code></p>
<p>TODO</p>
<a class="header" href="print.html#remove-entry" id="remove-entry"><h3>Remove Entry</h3></a>
<p>Canonical name: <code>remove_entry</code></p>
<p>TODO</p>
<a class="header" href="print.html#get-entry" id="get-entry"><h3>Get Entry</h3></a>
<p>Canonical name: <code>get_entry</code></p>
<p>Given an entry hash, returns the entry from the DHT if that entry exists.</p>
<p>Entry lookup is done in the following order:</p>
<ul>
<li>The local source chain</li>
<li>The local hash table</li>
<li>The distributed hash table</li>
</ul>
<p>Caller can request additional metadata on the entry such as type or sources
(hashes of the agents that committed the entry).</p>
<a class="header" href="print.html#get-links" id="get-links"><h3>Get Links</h3></a>
<p>Canonical name: <code>get_links</code></p>
<p>TODO</p>
<a class="header" href="print.html#remove-entry-1" id="remove-entry-1"><h3>Remove Entry</h3></a>
<p>Canonical name: <code>remove_entry</code></p>
<p>TODO</p>
<a class="header" href="print.html#query" id="query"><h3>Query</h3></a>
<p>Canonical name: <code>query</code></p>
<p>TODO</p>
<a class="header" href="print.html#send" id="send"><h3>Send</h3></a>
<p>Canonical name: <code>send</code></p>
<p>TODO</p>
<a class="header" href="print.html#start-bundle" id="start-bundle"><h3>Start Bundle</h3></a>
<p>Canonical name: <code>start_bundle</code></p>
<p>TODO</p>
<a class="header" href="print.html#close-bundle" id="close-bundle"><h3>Close Bundle</h3></a>
<p>Canonical name: <code>close_bundle</code></p>
<p>TODO</p>
<a class="header" href="print.html#zome-implementation" id="zome-implementation"><h1>Zome implementation</h1></a>
<a class="header" href="print.html#zome-api-functions-1" id="zome-api-functions-1"><h2>Zome API functions</h2></a>
<p>Each zome API function is implemented under <code>nucleus::ribosome::api</code>.</p>
<p>There is a fair bit of boilerplate at the moment, sorry!</p>
<p>To co-ordinate the execution of an API function across Rust and WASM we need to
define a few related items.</p>
<p>Within <code>nucleus::ribosome::api</code>:</p>
<ul>
<li>A variant in the <code>ZomeAPIFunction</code> enum</li>
<li>The same canonical string in <em>both</em> <code>as_str</code> and <code>from_str</code></li>
<li>A mapping to the API function under <code>as_fn</code></li>
</ul>
<p>As a new module under <code>nucleus::ribosome::api</code>:</p>
<ul>
<li>A ribosome module implementing the invocation logic as <code>invoke_*</code></li>
<li>A struct to hold/serialize any input args if needed</li>
</ul>
<p>In <code>::action</code>:</p>
<ul>
<li>An action if the zome API function has side effects</li>
</ul>
<a class="header" href="print.html#zome-api-function-definition" id="zome-api-function-definition"><h3>Zome API function definition</h3></a>
<p>Simply add the name of the new zome API function to the end of the enum.</p>
<p>Make sure to add the canonical names carefully. The Rust compiler will guide you
through the rest if you miss something.</p>
<p>DO add a doc comment summarising what the zome function does and sketching the
function signature.</p>
<p>DO extend the relevant unit tests.</p>
<p>Do NOT add to the start or middle of the enum as that will renumber the other
zome functions.</p>
<a class="header" href="print.html#zome-api-function-ribosome-module" id="zome-api-function-ribosome-module"><h3>Zome API function ribosome module</h3></a>
<p>Each zome API function should have its own module under <code>nucleus::ribosome::*</code>.</p>
<p>Implement a public function as <code>invoke_&lt;canonical name&gt;</code>. The function must take
two arguments, a <code>&amp;mut nucleus::ribosome::Runtime</code> and a <code>&amp;wasmi::RuntimeArgs</code>.</p>
<p>This function will be called by the invocation dispatch (see above).</p>
<a class="header" href="print.html#zome-api-function-arguments" id="zome-api-function-arguments"><h4>Zome API function arguments</h4></a>
<p>The <code>wasmi::RuntimeArgs</code> passed to the Zome API function contains only a single
<code>u32</code> value. This is an encoded representation of a single page of memory
supported by the memory manager. The 16 high bits are the memory offset and the
16 low bits are the memory length. See the <code>wasm_utils</code> crate for more
implementation details.</p>
<p>You don't have to work with the memory manager directly, simply pass the runtime
and runtime args to <code>nucleus::runtime_args_to_utf8</code> to get a utf-8 string from
memory.</p>
<p>You DO have to handle serialization round trips if you want to pass anything
other than a single utf-8 string to a zome API function.</p>
<p>The simplest way to do this is implement a struct that derives <code>Serialize</code> and
<code>Deserialize</code> from serde, then use serde and <code>.into_bytes()</code> co-ordinate the
round trip.</p>
<p>For an example implementation of a struct with several fields see:</p>
<ul>
<li><code>nucleus::ribosome::commit::CommitArgs</code> for the input args struct</li>
<li><code>nucleus::ribosome::commit::tests::test_args_bytes</code> serializing the struct as bytes</li>
<li><code>nucleus::ribosome::commit::invoke_commit</code> deserializing the struct from the runtime</li>
</ul>
<a class="header" href="print.html#zome-api-function-action-dispatch" id="zome-api-function-action-dispatch"><h4>Zome API function action dispatch</h4></a>
<p>If the function has a side effect it must send an action to the state reduction
layer.</p>
<p>Actions are covered in more detail in the state chapter.</p>
<p>In summary, if you want to send an action and wait for a return value:</p>
<ul>
<li>create an outer channel in the scope of your invoke function that will receive the return value</li>
<li>call <code>::instance::dispatch_action_with_observer</code> with:
<ul>
<li>the runtime's channels</li>
<li>the action the reducer will dispatch on</li>
<li>an observer sensor, which is a closure that polls for the action result and sends to your outer channel</li>
</ul>
</li>
<li>block the outer channel until you receive the action result</li>
</ul>
<a class="header" href="print.html#zome-api-function-return-values" id="zome-api-function-return-values"><h4>Zome API function return values</h4></a>
<p>The zome API function returns a value to wasm representing success or a wasm trap.</p>
<p>The success value can only be a single <code>i32</code>.</p>
<p>Traps are a low level wasm concern and are unlikely to be directly useful to a
zome API function implementation.</p>
<p>See https://github.com/WebAssembly/design/blob/master/Semantics.md#traps</p>
<p>To get complex values out of wasm we use the memory manager, much like the input
argument serialization (see above).</p>
<p>The util function <code>nucleus::runtime_allocate_encode_str</code> takes a string,
allocates memory and returns the value that the zome API function must return.</p>
<p>To return an error relevant to holochain, return <code>Ok</code> with an <code>HcApiReturnCode</code>
error enum variant.</p>
<p>For an example implementation returning a complex struct see:</p>
<ul>
<li><code>agent::state::ActionResult::Get</code> defining a result containing a <code>Pair</code> struct</li>
<li><code>nucleus::ribosome::get::invoke_get</code>
<ul>
<li>match the action result against the correct enum variant</li>
<li>serialize the pair using serde</li>
<li>return the result of <code>runtime_allocate_encode_str</code></li>
<li>if the action result variant does NOT match then return <code>HcApiReturnCode::ErrorActionResult</code></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#zome-api-function-agent-action" id="zome-api-function-agent-action"><h3>Zome API function agent action</h3></a>
<p>If the zome API function will cause side effects to the agent state then it must
implement and dispatch an action.</p>
<p>Actions are covered in more detail in the state chapter.</p>
<p>In summary, if a new agent action (for example) is needed:</p>
<ul>
<li>extend the <code>action::Action</code> enum
<ul>
<li>this sets the data type, the <code>ActionWrapper</code> provides a unique ID</li>
<li>use the canonical name if that makes sense</li>
</ul>
</li>
<li>extend an <code>ActionResult</code> enum if the action has a return value</li>
<li>implement a reducer for the new action</li>
</ul>
<a class="header" href="print.html#callback-functions" id="callback-functions"><h1>Callback functions</h1></a>
<a class="header" href="print.html#overview-2" id="overview-2"><h2>Overview</h2></a>
<p>A callback function is implemented in the zome language and called by Holochain.</p>
<p>Contrast this to a zome API function that is implemented by Holochain and called
by the zome.</p>
<p>Callback functions are passed some parameters and expected to return one of
three possible <code>CallbackParams</code> variants:</p>
<ul>
<li><code>Pass</code>: The callback function has executed/validated successfully</li>
<li><code>NotImplemented</code>: The callback function was not found in the current zome</li>
<li><code>Fail(String)</code>: The callback function failed for the given reason</li>
</ul>
<p>As per Zome API functions, the names of the callback functions may be slightly
different depending on the language. The canonical name follows Rust naming
conventions but other languages may vary these (e.g. camel casing).</p>
<p>To implement a callback function in a zome simply define it and Holochain will
call it automatically during standard internal workflows.</p>
<p>Return <code>true</code> or an empty string from the zome function to <code>Pass</code>.</p>
<p>Return <code>false</code> or a non-empty string from the zome function to <code>Fail</code>. The
string will be used as the <code>Fail</code> reason.</p>
<a class="header" href="print.html#reference-2" id="reference-2"><h2>Reference</h2></a>
<a class="header" href="print.html#genesis" id="genesis"><h3>Genesis</h3></a>
<p>Canonical name: <code>genesis</code>
Parameters: none</p>
<p>Called the first time a dApp initializes.</p>
<ul>
<li><code>Pass</code>: the dApp will initialize</li>
<li><code>NotImplemented</code>: the dApp will initialize</li>
<li><code>Fail</code> (any reason): the dApp will NOT initialize</li>
</ul>
<a class="header" href="print.html#validatecommit" id="validatecommit"><h3>ValidateCommit</h3></a>
<p>Canonical name: <code>validate_commit</code>
Parameters: The candidate entry to be committed</p>
<p>Called internally by the <code>commit</code> Zome API function.</p>
<ul>
<li><code>Pass</code>: the entry will be committed</li>
<li><code>NotImplemented</code>: the entry will be committed</li>
<li><code>Fail</code> (any reason): the entry will NOT be committed and <code>commit</code> will return a <code>HcApiReturnCode::ErrorCallbackResult</code> error code.</li>
</ul>
<a class="header" href="print.html#agent" id="agent"><h1>Agent</h1></a>
<a class="header" href="print.html#keys" id="keys"><h1>Keys</h1></a>
<a class="header" href="print.html#dna" id="dna"><h1>DNA</h1></a>
<a class="header" href="print.html#source-chain" id="source-chain"><h1>Source Chain</h1></a>
<a class="header" href="print.html#pairs" id="pairs"><h1>Pairs</h1></a>
<p>Pair has</p>
<p>Entry has
entry_type
content</p>
<p>The hash of a Header is the result of combining all of its properties and then getting the hash of that string.</p>
<p>Header has
entry_type
time
next // link to the immediately preceding header, None is valid only for genesis
entry
type_next // link to the most recent header of the same type, None is valid only for the first of type
signature // agents crptographic signature</p>
<a class="header" href="print.html#distributed-hash-table" id="distributed-hash-table"><h1>Distributed Hash Table</h1></a>
<a class="header" href="print.html#lifecycle-of-an-entry" id="lifecycle-of-an-entry"><h1>Lifecycle of an Entry</h1></a>
<a class="header" href="print.html#commit" id="commit"><h2>Commit</h2></a>
<pre><code>New entry
Validate commit
Commit to source chain
</code></pre>
<p>Entries must be committed to the local source chain before they can be broadcast
to the DHT.</p>
<p>Every entry must pass a ValidateCommit lifecycle function check before it can be
committed.</p>
<p>If ValidateCommit is not implemented for the zome committing the entry then this
is treated as a pass and the entry will be committed.</p>
<a class="header" href="print.html#links-entries" id="links-entries"><h1>Links Entries</h1></a>
<a class="header" href="print.html#core-api" id="core-api"><h1>Core API</h1></a>
<a class="header" href="print.html#wasm" id="wasm"><h1>WASM</h1></a>
<a class="header" href="print.html#command-line-tools" id="command-line-tools"><h1>Command Line Tools</h1></a>
<a class="header" href="print.html#holochain-across-platforms" id="holochain-across-platforms"><h1>Holochain Across Platforms</h1></a>
<a class="header" href="print.html#building-for-android" id="building-for-android"><h3>Building for Android</h3></a>
<p>Note: These instructions for building Holochain on Android are adapted from <a href="https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-21-rust-on-android.html">here</a>.</p>
<p>In order to get to libraries that can be linked against when building <a href="https://github.com/holochain/holosqape">HoloSqape</a> for Android, you basically just need to setup up according targets for cargo.</p>
<p>Given that the Android SDK is installed, here are the steps to setting things up for building:</p>
<ol>
<li>
<p>Install the Android tools:</p>
<p>a. Install <a href="https://developer.android.com/studio/">Android Studio</a>
b. Open Android Studio and navigate to SDK Tools:
- MacOS: <code>Android Studio &gt; Preferences &gt; Appearance &amp; Behaviour &gt; Android SDK &gt; SDK Tools</code>
- Linux: <code>Configure (gear) &gt; Appearance &amp; Behavior &gt; System Settings &gt; Android SDK</code>
c. Check the following options for installation and click OK:
* Android SDK Tools
* NDK
* CMake
* LLDB
d. Get a beverage of your choice (or a full meal for that matter) why you wait for the lengthy download</p>
</li>
<li>
<p>Setup ANDROID_HOME env variable:</p>
</li>
</ol>
<p>On MacOS</p>
<pre><code class="language-bash">export ANDROID_HOME=/Users/$USER/Library/Android/sdk
</code></pre>
<p>Linux: (assuming you used defaults when installing Android Studio)</p>
<pre><code class="language-bash">export ANDROID_HOME=$HOME/Android/Sdk
</code></pre>
<ol start="2">
<li>Create standalone NDKs (the commands below put the NDK in your home dir but you can put them where you like):</li>
</ol>
<pre><code class="language-bash">export NDK_HOME=$ANDROID_HOME/ndk-bundle
cd ~
mkdir NDK
${NDK_HOME}/build/tools/make_standalone_toolchain.py --api 26 --arch arm64 --install-dir NDK/arm64
${NDK_HOME}/build/tools/make_standalone_toolchain.py --api 26 --arch arm --install-dir NDK/arm
${NDK_HOME}/build/tools/make_standalone_toolchain.py --api 26 --arch x86 --install-dir NDK/x86
</code></pre>
<ol start="3">
<li>Add the following lines to your <code>~/.cargo/config</code>:</li>
</ol>
<pre><code class="language-toml">[target.aarch64-linux-android]
ar = &quot;&lt;your $HOME value here&gt;/NDK/arm64/bin/aarch64-linux-android-ar&quot;
linker = &quot;&lt;your $HOME value here&gt;/NDK/arm64/bin/aarch64-linux-android-clang&quot;

[target.armv7-linux-androideabi]
ar = &quot;&lt;your $HOME value here&gt;/NDK/arm/bin/arm-linux-androideabi-ar&quot;
linker = &quot;&lt;your $HOME value here&gt;/NDK/arm/bin/arm-linux-androideabi-clang&quot;

[target.i686-linux-android]
ar = &quot;&lt;your $HOME value here&gt;/NDK/x86/bin/i686-linux-android-ar&quot;
linker = &quot;&lt;your $HOME value here&gt;/NDK/x86/bin/i686-linux-android-clang&quot;

</code></pre>
<p>(this toml file needs absolute paths, so you need to prefix the path with your home dir).</p>
<ol start="4">
<li>Now you can add those targets to your rust installation with:</li>
</ol>
<pre><code>rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android
</code></pre>
<p>Finally, should now be able to build Holochain for Android with your chosen target, e.g.:</p>
<pre><code>cd &lt;holochain repo&gt;
cargo build --target armv7-linux-androideabi --release
</code></pre>
<p><strong>NOTE:</strong>  there is currently a problem in that <code>wabt</code> (which we use in testing as a dev dependency) won't compile on android, and the cargo builder compiles dev dependencies even though they aren't being used in release builds.  Thus as a work around, for the cargo build command above to work, you need to manually comment out the dev dependency section in both <code>core/Cargo.toml</code> and <code>core_api/Cargo.toml</code></p>
<a class="header" href="print.html#going-live-with-holochain-apps-1" id="going-live-with-holochain-apps-1"><h1>Going Live with Holochain Apps</h1></a>
<a class="header" href="print.html#extending-the-hc-platform" id="extending-the-hc-platform"><h1>Extending the HC Platform</h1></a>
<a class="header" href="print.html#state--actions" id="state--actions"><h1>State &amp; Actions</h1></a>
<p>Holochain uses a hybrid global/local state model.</p>
<p>In our bio mimicry terms the global state is for &quot;short term memory&quot; and local
state wraps references to &quot;long term memory&quot;.</p>
<p>The global state is implemented as Redux style reducers. Any module can dispatch
an action to the global state. The action will be &quot;reduced&quot; to a new state tree
value by the modules responsible for each branch of the state tree. The response
values from a reduction must be polled directly from the state tree in a thread
using a &quot;sensor&quot; closure in an observer.</p>
<p>Actions are stateless/immutable data structures that are dispatched by modules
to communicate a request to do something potentially state changing. Everything
in the system should be either stateless or change state only in response to an
incoming action.</p>
<p>The global state is called &quot;short term memory&quot; because it is highly dynamic,
readily inspectable, and volatile. It does not survive indefinitely and is best
thought of as a cache of recent history.</p>
<p>Local state is implemented using actors to co-ordinate memory and threads in
Rust for external, persistent state. The classic example is a database
connection to the database that stores entries and headers. The db actor
receives read/write messages, and a reference to the sender is stored in the
global state.</p>
<a class="header" href="print.html#actions" id="actions"><h2>Actions</h2></a>
<p>The <code>action</code> module defines actions and action wrappers:</p>
<ul>
<li><code>ActionWrapper</code>: struct contains a unique ID for the action and the <code>Action</code></li>
<li><code>Action</code>: enum of specific data to a given action, e.g. <code>Action::Commit</code></li>
</ul>
<p>Processing an incoming action is a 3 step process:</p>
<ol start="0">
<li>Implement <code>reduce</code> to resolve and dispatch to a handler</li>
<li>Resolve the action to an appropriate handler</li>
<li>Implement handler logic</li>
</ol>
<a class="header" href="print.html#reduce" id="reduce"><h3>Reduce</h3></a>
<p>The <code>reduce</code> implementation is essentially copypasta. It handles resolving and
dispatching to a handler with a new state clone. The handler resolution and
dispatch logic should be split to facilitate clean unit testing.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn reduce(
    old_state: Arc&lt;FooState&gt;,
    action_wrapper: &amp;ActionWrapper,
    action_channel: &amp;Sender&lt;ActionWrapper&gt;,
    observer_channel: &amp;Sender&lt;Observer&gt;,
) -&gt; Arc&lt;AgentState&gt; {
  let handler = resolve_action_handler(action_wrapper);
  match handler {
      Some(f) =&gt; {
          let mut new_state: FooState = (*old_state).clone();
          f(&amp;mut new_state, &amp;action_wrapper, action_channel, observer_channel);
          Arc::new(new_state)
      }
      None =&gt; old_state,
  }
}
#}</code></pre></pre>
<a class="header" href="print.html#resolve-an-appropriate-handler" id="resolve-an-appropriate-handler"><h3>Resolve an appropriate handler</h3></a>
<p>The action handler should map signals to action handlers.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn resolve_action_handler(
    action_wrapper: &amp;ActionWrapper,
) -&gt; Option&lt;fn(&amp;mut AgentState, &amp;ActionWrapper, &amp;Sender&lt;ActionWrapper&gt;, &amp;Sender&lt;Observer&gt;)&gt; {
    match action_wrapper.action() {
        Action::Commit(_, _) =&gt; Some(handle_commit),
        Action::Get(_) =&gt; Some(handle_get),
        _ =&gt; None,
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#implement-the-handlers" id="implement-the-handlers"><h3>Implement the handlers</h3></a>
<p>Each handler should respond to one action signal and mutate the relevant state.</p>
<p>The standard pattern is to maintain a <code>HashMap</code> of incoming action wrappers
against the result of their action from the perspective of the current module.
Each action wrapper has a unique <code>id</code> internally so there will be no key
collisions.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn handle_foo(
    state: &amp;mut FooState,
    action_wrapper: &amp;ActionWrapper,
    _action_channel: &amp;Sender&lt;ActionWrapper&gt;,
    _observer_channel: &amp;Sender&lt;Observer&gt;,
) {
    let action = action_wrapper.action();
    let bar = unwrap_to!(action =&gt; Action::Bar);

    // do something with bar...
    let result = bar.do_something();

    state
        .actions
        .insert(action_wrapper.clone(), ActionResponse::Bar(result.clone()));
}
#}</code></pre></pre>
<p>WARNING: Actions are reduced in a simple loop. Holochain will hang if you
dispatch and block on a new action while an outer action reduction is also
blocking, waiting for a response.</p>
<a class="header" href="print.html#global-state" id="global-state"><h2>Global state</h2></a>
<p><code>instance::Instance</code> has a <code>state::State</code> which is the one global state. Each
stateful module has a <code>state.rs</code> module containing sub-state slices.</p>
<p>See <code>src/agent/state.rs</code> and <code>src/nucleus/state.rs</code> and how they are put
together in <code>src/state.rs</code>.</p>
<p>State is read from the instance through relevant getter methods:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
instance.state().nucleus().dna()
#}</code></pre></pre>
<p>and mutated by dispatching an action:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let entry = Entry::new( ... );
let action_wrapper = ActionWrapper::new(&amp;Action::Commit(entry));
instance.dispatch(action_wrapper);
#}</code></pre></pre>
<p>Instance calls reduce on the state with the next action to consume:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn consume_next_action(&amp;mut self) {
    if self.pending_actions.len() &gt; 0 {
        let action = self.pending_actions.pop_front().unwrap();
        self.state = self.state.clone().reduce(&amp;action);
    }
}
#}</code></pre></pre>
<p>The main reducer creates a new State object and calls the sub-reducers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn reduce(&amp;mut self, action_wrapper: &amp;ActionWrapper) -&gt; Self {
    let mut new_state = State {
        nucleus: ::nucleus::reduce( ... ),
        agent: ::agent::reduce( ... )
    }

    new_state.history.insert(action_wrapper);
    new_state
}
#}</code></pre></pre>
<p>Each incoming action wrapper is logged in the main state <code>history</code> to facilitate
testing and &quot;time travel&quot; debugging.</p>
<p>Sub-module state slices are included in <code>state::State</code> as counted references.</p>
<p>The sub-module reducer must choose to either:</p>
<ul>
<li>If mutations happen, return a cloned, mutated state slice with a new reference</li>
<li>If no mutations happen, return the reference to the original state slice</li>
</ul>
<p>The <code>reduce</code> copypasta above demonstrates this as the possible return values.</p>
<p>Redux in Rust code was used as a reference from <a href="https://github.com/rust-redux/rust-redux">this repository</a>.</p>
<a class="header" href="print.html#local-state" id="local-state"><h2>Local state</h2></a>
<p>Coming Soon.</p>
<p>@TODO
@see https://github.com/holochain/holochain-rust/issues/176</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
